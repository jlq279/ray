#include "trimesh.h"
#include <assert.h>
#include <float.h>
#include <string.h>
#include <algorithm>
#include <cmath>
#include "../ui/TraceUI.h"
extern TraceUI* traceUI;

using namespace std;

Trimesh::~Trimesh()
{
	for (auto m : materials)
		delete m;
	for (auto f : faces)
		delete f;
}

// must add vertices, normals, and materials IN ORDER
void Trimesh::addVertex(const glm::dvec3& v)
{
	vertices.emplace_back(v);
}

void Trimesh::addMaterial(Material* m)
{
	materials.emplace_back(m);
}

void Trimesh::addNormal(const glm::dvec3& n)
{
	normals.emplace_back(n);
}

// Returns false if the vertices a,b,c don't all exist
bool Trimesh::addFace(int a, int b, int c)
{
	int vcnt = vertices.size();

	if (a >= vcnt || b >= vcnt || c >= vcnt)
		return false;

	TrimeshFace* newFace = new TrimeshFace(
	        scene, new Material(*this->material), this, a, b, c);
	newFace->setTransform(this->transform);
	if (!newFace->degen)
		faces.push_back(newFace);
	else
		delete newFace;

	// Don't add faces to the scene's object list so we can cull by bounding
	// box
	return true;
}

// Check to make sure that if we have per-vertex materials or normals
// they are the right number.
const char* Trimesh::doubleCheck()
{
	if (!materials.empty() && materials.size() != vertices.size())
		return "Bad Trimesh: Wrong number of materials.";
	if (!normals.empty() && normals.size() != vertices.size())
		return "Bad Trimesh: Wrong number of normals.";

	return 0;
}

bool traverse(KdTree<TrimeshFace>* tree, ray& r, isect& i) {
	double tMin;
	double tMax;
	BoundingBox bound = tree->getBound();
	if (bound.intersect(r, tMin, tMax)) {
		KdTree<TrimeshFace>* left = tree->getLeft();
		KdTree<TrimeshFace>* right = tree->getRight();
		if (tree->isLeaf()) {
			for (auto& face : tree->getObjects()) {
				auto b = face.get()->getBoundingBox();
				isect cur;
				if( face->intersectLocal(r, cur) ) {
					if(i.getT() == 0 || cur.getT() < i.getT()) {
						i = cur;
						return true;
					}
				}
			}
			return false;
		}
		bool leftIntersect = left == NULL ? false : traverse(left, r, i);
		bool rightIntersect = right == NULL ? false : traverse(right, r, i);
		return leftIntersect || rightIntersect;
	}
	else {
		return false;
	}
}

bool Trimesh::intersectLocal(ray& r, isect& i) const
{
	bool have_one = traverse(kdTree, r, i);
	if (!have_one)
		i.setT(1000.0);
	return have_one;
}

bool TrimeshFace::intersect(ray& r, isect& i) const
{
	return intersectLocal(r, i);
}

// Intersect ray r with the triangle abc.  If it hits returns true,
// and put the parameter in t and the barycentric coordinates of the
// intersection in u (alpha) and v (beta).
bool TrimeshFace::intersectLocal(ray& r, isect& i) const
{
	// YOUR CODE HERE
	//
	// FIXME: Add ray-trimesh intersection
	int a = ids[0];
	int b = ids[1];
	int c = ids[2];

	glm::dvec3 a_coords = parent->vertices[a];
	glm::dvec3 b_coords = parent->vertices[b];
	glm::dvec3 c_coords = parent->vertices[c];

	glm::dvec3 vab = (b_coords - a_coords);
	glm::dvec3 vbc = (c_coords - b_coords);
	glm::dvec3 vca = (a_coords - c_coords);

	glm::dvec3 o = r.getPosition();
	glm::dvec3 v = r.getDirection();

	double t = glm::dot((a_coords - o), normal)/glm::dot(v, normal);
	glm::dvec3 p_coords = o + v * t;

	glm::dvec3 vap = (p_coords - a_coords);
	glm::dvec3 vbp = (p_coords - b_coords);
	glm::dvec3 vcp = (p_coords - c_coords);

	glm::dvec3 a_cross = glm::cross(vab, vap);
	glm::dvec3 b_cross = glm::cross(vbc, vbp);
	glm::dvec3 c_cross = glm::cross(vca, vcp);

	bool intersecting = glm::dot(a_cross, normal) >= 0 && glm::dot(b_cross, normal) >= 0 && glm::dot(c_cross, normal) >= 0;

	if (intersecting && t > 0) {
		i.setT(t);
		auto coordinates = glm::inverse(glm::mat2x2(glm::dot(vab, vab), glm::dot(-vca, vab), glm::dot(vab, -vca), glm::dot(-vca, -vca))) * glm::dvec2(glm::dot(vap, vab), glm::dot(vap, -vca));
		double alpha = coordinates.x;
		double beta = coordinates.y;
		double gamma = 1 - alpha - beta;
		glm::dvec3 n = normal;
		Material m = this->getMaterial();
		if (parent->normals.size() > 0 && parent->vertNorms){
			n = glm::normalize(gamma * parent->normals[a] + alpha * parent->normals[b] + beta * parent->normals[c]);
		}
		if (parent->materials.size() > 0) {
			Material materialA = *parent->materials[a];
			Material materialB = *parent->materials[b];
			Material materialC = *parent->materials[c];
			m = gamma * materialA + alpha * materialB + beta * materialC;
		}

		i.setN(n);
		i.setObject(this);
		i.setMaterial(m);
		i.setBary(gamma, alpha, beta);
		return true;
	}
	return false;
}

// Once all the verts and faces are loaded, per vertex normals can be
// generated by averaging the normals of the neighboring faces.
void Trimesh::generateNormals()
{
	int cnt = vertices.size();
	normals.resize(cnt);
	std::vector<int> numFaces(cnt, 0);

	for (auto face : faces) {
		glm::dvec3 faceNormal = face->getNormal();

		for (int i = 0; i < 3; ++i) {
			normals[(*face)[i]] += faceNormal;
			++numFaces[(*face)[i]];
		}
	}

	for (int i = 0; i < cnt; ++i) {
		if (numFaces[i])
			normals[i] /= numFaces[i];
	}

	vertNorms = true;
}

bool compareX(std::unique_ptr<TrimeshFace>& a, std::unique_ptr<TrimeshFace>& b) {
	if (a->getBoundingBox().getMin().x == b->getBoundingBox().getMin().x) {
		if (a->getBoundingBox().getMax().x == b->getBoundingBox().getMax().x) {
			return sqrt(pow(a->getBoundingBox().getMax().x, 2) + pow(a->getBoundingBox().getMax().y, 2) + pow(a->getBoundingBox().getMax().z, 2)) < sqrt(pow(b->getBoundingBox().getMax().x, 2) + pow(b->getBoundingBox().getMax().y, 2) + pow(b->getBoundingBox().getMax().z, 2));
		}
		return a->getBoundingBox().getMax().x < b->getBoundingBox().getMax().x;
	}
	return a->getBoundingBox().getMin().x < b->getBoundingBox().getMin().x;
}

bool compareY(std::unique_ptr<TrimeshFace>& a, std::unique_ptr<TrimeshFace>& b) {
	if (a->getBoundingBox().getMin().y == b->getBoundingBox().getMin().y) {
		if (a->getBoundingBox().getMax().y < b->getBoundingBox().getMax().y) {
			return sqrt(pow(a->getBoundingBox().getMax().x, 2) + pow(a->getBoundingBox().getMax().y, 2) + pow(a->getBoundingBox().getMax().z, 2)) < sqrt(pow(b->getBoundingBox().getMax().x, 2) + pow(b->getBoundingBox().getMax().y, 2) + pow(b->getBoundingBox().getMax().z, 2));
		}
		return a->getBoundingBox().getMax().y < b->getBoundingBox().getMax().y;
	}
	return a->getBoundingBox().getMin().y < b->getBoundingBox().getMin().y;
}

bool compareZ(std::unique_ptr<TrimeshFace>& a, std::unique_ptr<TrimeshFace>& b) {
	if (a->getBoundingBox().getMin().z == b->getBoundingBox().getMin().z) {
		if (a->getBoundingBox().getMax().z == b->getBoundingBox().getMax().z) {
			return sqrt(pow(a->getBoundingBox().getMax().x, 2) + pow(a->getBoundingBox().getMax().y, 2) + pow(a->getBoundingBox().getMax().z, 2)) < sqrt(pow(b->getBoundingBox().getMax().x, 2) + pow(b->getBoundingBox().getMax().y, 2) + pow(b->getBoundingBox().getMax().z, 2));
		}
		return a->getBoundingBox().getMax().z < b->getBoundingBox().getMax().z;
	}
	return a->getBoundingBox().getMin().z < b->getBoundingBox().getMin().z;
}

void buildKdTreeR(KdTree<TrimeshFace>* tree) {
	int numObjects = tree->getNumObjects();
	BoundingBox bound = tree->getBound();
	auto min = bound.getMin();
	auto max = bound.getMax();
	auto minX = min.x;
	auto maxX = max.x;
	auto minY = min.y;
	auto maxY = max.y;
	auto minZ = min.z;
	auto maxZ = max.z;
	auto difference = max - min;
	if (numObjects == 1) {
		return;
	}
	KdTree<TrimeshFace>* left;
	KdTree<TrimeshFace>* right;
	if (difference.x >= difference.y && difference.x >= difference.z) {
		sort(tree->getObjects().begin(), tree->getObjects().end(), compareX);
	}
	else if (difference.y >= difference.x && difference.y >= difference.z) {
		sort(tree->getObjects().begin(), tree->getObjects().end(), compareY);
	}
	else {
		sort(tree->getObjects().begin(), tree->getObjects().end(), compareZ);
	}
	auto half = tree->getObjects().size()/2;
	left = new KdTree<TrimeshFace>();
	std::vector<std::unique_ptr<TrimeshFace>> leftObjects;
	right = new KdTree<TrimeshFace>();
	std::vector<std::unique_ptr<TrimeshFace>> rightObjects;
	for (auto object = tree->getObjects().begin(); object < tree->getObjects().end(); object++) {
		if (object < tree->getObjects().begin() + half) {
			left->addObject(object->get());
			left->updateBound(object->get()->getBoundingBox());
		}
		else {
			right->addObject(object->get());
			right->updateBound(object->get()->getBoundingBox());
		}
	}
	if (left->getNumObjects() > 0) {
		tree->setLeft(left);
		buildKdTreeR(tree->getLeft());
	}
	if (right->getNumObjects() > 0) {
		tree->setRight(right);
		buildKdTreeR(tree->getRight());
	}
}

void Trimesh::buildKdTree() {
	kdTree = new KdTree<TrimeshFace>();
	for ( auto face : faces ) {
		auto bb = face->getBoundingBox();
		kdTree->addObject(face);
		kdTree->updateBound(bb.getMin(), bb.getMax());
	}
	buildKdTreeR(kdTree);
}
